---
title: "[Java] 클래스 객체 생성자 은닉성"
date: 2023-11-16 00:00:00 +0900
categories: [Programming-Language, Java]
tags: [java]
render_with_liquid: false
future: true
---
**1\. 객체**

**1-1. 객체지향 프로그래밍과 객체**

\- 동일한 설계로 만들어진 자동차라 하더라도 각각의 자동차를 구성하는 부품들은 그 형태만 같은 뿐, 실제로는 독립적으로 존재하게 됩니다.

\- 클래스를 작성하면서 그 안에 생성되는 멤버변수들은 여러 개의 객체 간에 서로 동일한 이름으로 존재하지만 실제로는 서로 다른 값이라는 의미입니다.

![Desktop View](/assets/img/Programming-Language/Java/Class-Instance-Generator-Capsule/1.png)

**1-2. 클래스의 기본 작성 방법**

\- class 클래스이름{

멤버변수;

void 메서드이름(){

..

}

}

\- 'class'라는 예약어와 클래스의 이름을 명시하고 {...} 블록을 구성합니다.

\- 멤버변수는 여러 개 존재할 수 있다. 이 때, 값을 선언과 동시에 할당할 수 도 있고, 객체를 통해 간접적으로 할당할 수도 있습니다.

\- 메서드는 여러 개 존재할 수 있습니다.

\- 클래스 안에 포함된 멤버변수와 메서드를 특성에 따라 그룹화 하기 위한 기법이 클래스를 작성하는 것이라고 이해할 수 있습니다.

**1-3. 객체의 선언 방법**

\- 객체의 선언

클래스이름 객체이름;

\- 객체의 할당

객체이름 = new 클래스이름();

\- 객체의 선언과 할당의 톻합

클래스이름 객체이름 = new 클래스이름();

**1-4. 객체의 사용**

\- 객체 안에 포함된 변수나 메서드는 점(.)으로 연결하여 접근할 수 있습니다.

\-> 객체 안에 포함된 변수의 값을 다른 변수에 복사하는 경우

값 = 객체이름. 멤버변수;

\-> 객체 안에 포함된 메서드를 호출하는 경우

객체이름. 메서드이름();

\-> 객체 안에 포함된 메서드에 파라미터를 전달하는 경우

객체이름. 메서드이름(값,값2,값3...값n);

**1-5. 클래스를 정의하면서 멤버변수에 값을 직접 대입하는 경우**

\- 앞 예제(Main01.java)는 객체를 생성함과 동시에 객체 안에 name변수와 age변수가 할당된 값을 포함하게 됩니다.

\- 같은 클래스로 객체를 여러 개 생성할 경우, 모든 객체가 동일한 값을 갖게 됩니다.

\- 같은 클래스를 통하여 생성된 객체라 할지라도 서로 다른 값을 대입하면 서로 독립적인 형태로 존재하게 됩니다.

\- 클래스란 객체를 위한 틀을 제공하는 것이기 때문에 클래스 작성과정에서 멤버변수에 대입된 값은, 객체를 통하여 멤버변수의 값을 지정하기 전까지 사용된 "기본값"으로서의 의미입니다.

\- 객체를 통하여 새로운 값이 대입되면 클래스 작성시에 멤버변수에 대입한 값은 의미를 잃어버리게 됩니다.

\- 때문에 일반적으로 클래스 작성시에는 멤버변수에 값을 지정하지 않습니다.

**1-6. 메서드를 포함하는 클래스**

\- 메서드란 프로그램에서 하나의 동작 단위를 의미합니다.

\- 두 개 이상의 메서드가 서로 동일한 대상을 위해서 존재할 경우, 이 메서드를 클래스에 포함시켜 그룹화 할 수 있습니다.

**1-7. 변수의 종류**

\- 멤버변수(=전역변수)

\-> 클래스 안에서 선언된 변수로서, 클래스 블록 범위 안에서 유효합니다.

\- 지역변수

\-> 메서드 안에서 선언된 변수로서, 메서드의 블록을 빠져나가지 못합니다. 그러므로 다른 메서드는 해당 변수를 인식하지 못한다. 이 규칙은 조건문, 반복문과 같은 블럭{}을 형성하는 모든 경우에 해당합니다.

**1-8. 메서드만을 포함하는 클래스**

\- 객체 안에 멤버변수(=데이터)가 포함되지 않습니다.

\- 객체 안에 포함된 메서드를 호출하여 결과를 만들기 위한 목적이므로 굳이 여러 개의 객체를 생성할 필요가 없습니다.

\-> 계산기능을 갖는 클래스의 예

```

class Calc{

int sum(int x, int y){

return x +y;

}

}
```

\-> 기능의 활용 - 두 개의 값을 위하여 객체를 각자 생성하는 경우

```

Calc c1 = new Calc();

int a = c1.sum(10,20);

Calc c2 = new Calc();

int b =c2.sum(100,200);

```

\- 파라미터에 의해 결과를 리턴하는 경우, 서로 다른 값을 위해서 객체를 여러 개 생성할

필요가 없습니다.

\- 자체적으로 데이터를 갖는 형태가 아니라 외부적인 요인인 파라미터에 의해서 결과가

생성되므로, 하나의 객체를 재사용하는 것이 바람직합니다.

```
Calc c1 =new Calc();

int a = c1.sum(10,20);

int b = c1.sum(100,200);
```

**1-9. this**

\- 자기 자신을 의미하는 키워드

\- 클래스 안에서 this를 사용하여 "자기자신"을 표현합니다.

\- this를 사용해서 지역변수와 멤버변수를 구분할 수 있습니다.

```

class Foo{

String name;


public void setName(){

String name;

name = "자바학생";

this.name = "JSP학생";

}

}
```

\-> 멤버변수와 지역변수가 동일한 이름으로 공존할 경우, 유효성 범위가 작은

변수가 우선적으로 인식됩니다.

\-> this.name : 전역변수, name : 지역변수

\- 파라미터도 해당 메서드 안에서만 유효한 지역변수의 일종입니다.

\- 파라미터를 사용하여 멤버변수의 값을 간접적으로 설정하고자 할 경우,

변수의 이름을 서로 다르게 사용하는 것 보다는 이름은 동일하게 지정하고 this키워드를 사용하여

멤버변수와 파라미터를 구별하는 것이 Java언어의 일반적인 처리 방식입니다.

```

class Foo{

String name;


public void setName( String name){

this.name=name;

}

}

```

\-> 모든 멤버변수 앞에는 this 키워드를 사용하여 멤버변수임을 직관적으로 표시하는

것이 소스코드의 가독성을 위하여 바람직합니다.

**1-10. 현재 클래스의 메서드를 의미하는 용도로서의 this**

```

class Foo{

public String getName(){

String name = "자바학생";

return name;

}


public void sayName(){

String myName = this.getName();

System.out.println(myName);

}

}
```

\-> getName()메서드는 this키워드를 사용하여 현재 클래스 안에 포함된 다른

메서드임을 명시하고 있습니다.

\-> 하지만 메서드의 경우 다른 클래스의 메서드를 이름만으로 호출할 수 있는 방법이

없기 때문에, this.getName()이 아닌,getName()만 사용하더라도 코드 가독성의

문제는 없습니다.

**2\. 클래스, 메서드, 상수의 이름 규칙**

**2-1. 공통 이름 규칙**

\- 영어 + 숫자 + 언더바(\_)의 조합이고, 첫 글자는 반드시 영어로 표기합니다.

**2-2. 클래스 이름 규칙**

\- 첫 글자는 대문자로 시작, 나머지 글자는 소문자로 표시합니다.

\- 두 개 이상의 단어를 조합해야 할 경우 새로운 단어는 대문자로 시작합니다.

(ex. class MyClass, class Student, class NetworkHelper)

**2-3. 메서드, 변수 이름 규칙**

\- 대부분 소문자로 구성되지만, 두 개 이상의 단어를 조합할 경우 새로운 단어는 대문자로

표시합니다.

(ex. int age, String name, String userName, String memberCount)

**2-4. 상수 이름 규칙**

\- 모두 대문자로 표시합니다.

(ex. final double PI, final int COLOR)

**3\. 생성자**

**3-1. 생성자란?**

\- Cal c = new Calc();

\- new 키워드를 사용하여 객체가 생성될 때 자동으로 실행되는 특수한 형태의 메서드.

\- 리턴형을 명시하지 않으며, 메서드의 이름은 클래스와 동일합니다.

```

class Foo{

Foo(){

// 이 안은 객체가 생성될 때 자동으로 호출됩니다.

}

}
```

\- 자동으로 실행된다는 특성 때문에, 객체가 생성되면서 해당 객체의 특성을 초기화 하기

위하여 사용됩니다.

(ex: 멤버변수의 초기값을 할당하는 용도)

**3-2. 기본 생성자**

\- 파라미터가 없는 생성자

\- 클래스에 특별히 생성자가 정의되지 않은 경우

Java컴파일러는 다음과 같은 기본 생성자가 존재한다고 인식합니다.

```

class Foo{

Foo(){

// 생성자는 있지만, 내용은 비어있습니다.

}

}
```

**3-3. 파라미터를 갖는 생성자**

\-생성자도 메서드의 한 종류이므로 파라미터를 함께 정의하는 것이 가능합니다.

\-생성자의 파라미터를 멤버변수에 복사하는 것으로 객체의 초기화를 외부적인 요인에

의해 처리할 수 있습니다.

```

class Foo{

String name;

int age;


Foo(String name, int age ){

// 생성자의 파라미터의 값을 멤버변수에 복사

this. name = name;

this. age = age;

}

}
```

\- 생성자에 파라미터가 정의된 경우 객체 생성 구문에서 해당 파라미터를 전달해야 합니다.

```
Foo obj = new Foo("자바학생", 30);
```

**4\. 은닉성**

**4-1. 은닉성이란?**

\- 멤버변수나 메서드가 객체에 노출되지 않도록 설정하는 기법

\- 객체를 사용하는 측의 실수로 인한 기능의 오작동을 방지하기 위해, 클래스의 일부를 숨기는

처리를 말합니다.

**4-2. 적용방법**

\- 변수의 이름이나 메서드 이름 앞에 "접근 한정자"를 지정합니다.

접근 한정자 설명

public 모든 곳에서 접근 가능합니다. 일반적으로 모든 메서드 앞에 명시합니다.

private 클래스 안에서만 사용가능하고, 객체를 통해 접근할 수 없습니다. 일반적으로 모든 멤버변수 앞에 명시합니다.

protected 현재 클래스 내의 다른 자원이나, 같은 패키지 안에 존재하는 클래스와 하위 클래스에서 접근가능합니다.

잘 사용하지 않습니다.

default 접근 한정자를 명시하지 않는 경우, 현재 클래스 내의 다른 자원이나 동일 패키지 내의 다른 클래스에서 접근 가능합니다.

역시 잘 사용하지 않습니다.

**4-3. getter, setter**

\-멤버변수가 은닉된 형태로 선언된 경우 프로그램의 가장근본적 목적인 데이터에 접근하는 방법이 사라지므로 메서드를 통하여 간접적으로 접근하는 방법이 마련되어야 합니다.

\-getter, setter는 은닉된 멤버변수에 간접적으로 접근하기 위하여 정의된 메서드들을 의미하는 용어입니다.

\->Getter : 은닉된 멤버변수의 값을 리턴하기 위한 메서드

\->Setter : 파라미터로 전달될 값을 멤버변수에 복사하기 위한 메서드

멤버변수 getter setter

String userName String getUserName() void setUserName(String param)

int userAge int getUserAge() void setUserAge(int param)

\-> 'get', 'set' 접두사 뒤에 변수이름을 첫 글자가 대문자인 형태로 명시

\-> geter는 연결된 멤버변수의 데이터 타입을 리턴형으로 명시

\-> setter는 연결된 멤버변수의 데이터 타입을 파라미터 형으로 명시

**4-4. 클래스와 접근 한정자**

접근한정자 설명

public 객체생성이 가능합니다.

서로 다른 소스코드에 정의된 클래스끼리도 객체 생성이 가능합니다.

private 클래스에 적용할 수 없습니다.

protected 클래스에 적용할 수 없습니다.

default 동일한 소스코드에 정의된 클래스끼리만 객체로 생성 가능합니다.

(지금까지의 예제 형태)

\- 클래스의 분리

\-> 하나의 소스코드에서 프로그램의 모든 기능을 구현하게 되면 유지보수에 비효율적이므로, 기능단위로 소스코드를 분리해야 합니다.

\-> 소스코드가 분리된 클래스끼리는 public이 명시되어야만 서로 객체 생성이 가능합니다.

\-> 일반적으로 클래스 정의에는 public 접근 한정자만 사용합니다.

\-> 하나의 소스코드에는 하나의 public 클래스만 존재할 수 있습니다.

**4-5. 자바빈즈(Java Beans)**

\-자바 언어에서 사용하는 복합적 데이터 표현의 최소 단위로서, 재사용 가능한 컴포넌트(구성요소)를 생성할 수 있습니다.

\- 자바 관련 소프트웨어 개발에 있어 재사용이 가능한 표준 컴포넌트 모델

\- 자바빈즈 클래스로서 작동하기 위해서, 객체 클래스는 명명법, 생성법 그리고 행동에 관련된 일련의 관례를 따라야만 합니다. 이러한 관례는 (빌더 형식의)개발 도구에서 자바빈즈와 연결을 통해 클래스의 사용과 재사용 그리고 클래스의 재배치를 가능하게 합니다.

\-지켜야할 관례

\-> 클래스는 생성자를 가지고 있어야합니다.

\-> 클래스의 속성은 get, set 명명법을 따르는 메서드들을 사용해 접근할 수 있어야합니다.