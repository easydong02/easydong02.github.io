---
title: 함수 2차원배열
date: 2023-11-12 14:10:00 +0900
categories: [Programming-Language, Java]
tags: [java]
render_with_liquid: false
---


이번시간에는 저번시간에 이은 2차원 배열 살짝 알아보고 메소드에 대해서 알아보겠습니다~

**\*2차원 배열**
열
쉽게 말하면 배열 안에 배열입니다. 그리고 행, 열의 개념인데요. 실제로는 1차원 배열에 있던 하나의 칸에 다시 열의 개수로 쪼개지는 겁니다. 예를 들어, arrData\[3\]\[3\] 에서 arrData 의 주소값은 arrData\[0\]\[0\]인데 여기서 +1을 한다면 arrData\[0\]\[1\]이 아니라 arrData\[1\]\[0\]이 됩니다.

2차원 배열 선언

자료형\[\]\[\] 배열명 = { {값1,값2,...} , ...};

자료형\[\]\[\] 배열명 = new 자료형\[행\]\[열\];

2차원 배열부터는 메모리 낭비가 심하기 때문에 선호하지 않는다고 하네요.

그래도 하나 만들어 봅시다.

```
int[][] arrData  = {{2,4,6},{1,3,5}};

int length = arrData.length * arrData[0].length;

for (int i = 0; i < arrData.length; i++) {
			for (int j = 0; j < arrData[i].length; j++) {
				System.out.println(arrData[i][j]);
			}
		}
```

먼저 2차원 배열을 선언하여 값을 집어 넣었습니다. 1행에는 2,4,6 이 들어있고 2행에는 1,3,5 가 들어있네요.

그리고 length라는 변수를 만들었는데요. 2차원 배열같은 경우 .length를 하게 되면 행의 길이만 나옵니다. 여기선 2만 출력 되겠네요. 근데 우리는 전체 길이의 개수를 알고싶기 때문에 아무 행의 길이 arrData\[0\].length를 곱해서 전체 길이를 나타내었습니다.

그다음은 이중 for문으로 출력을 하도록 했습니다. i는 행을 나타낼거니까 그대로 arrData.length를 입력하면 되는데, j는 그 행 안에 있는 열의 개수기 때문에 만약 정방 배열이 아닐 때에는 곤란한 상황을 겪을수도 있습니다.그래서 arrData\[i\].length로 그 행이 가지고 있는 열의 개수를 추출합니다.

**\*메소드**

이름 뒤에 소괄호가 보통 붙습니다.

단, 키워드 뒤에 소괄호는 메소드가 아니라고 하네요.

용어는 이렇습니다.

f (x) = 2x + 1

여기서 f는 메소드 명이고 괄호 안에 있는 변수는 매개변수라고 합니다. 그리고 그 뒤에는 리턴값입니다. 이 큰 틀로 메소드가 이루어집니다.

**메소드의 선언**

리턴타입 메소드명(자료형 매개변수1, ...){

실행할 문장;

return 리턴값;

}

이런식으로 이 전체의 메소드가 하나의 리턴값을 가진다고 보면 됩니다. 그리고 그 값은 매개 변수에 따라 다르겠지요?

하나씩 설명하자면, 리턴타입은 이 메소드가 가지는 리턴값의 타입을 말합니다. 리턴 값이 없는 메소드의 경우에는 void를 적어줍니다. 메소드명은 메소드의 이름입니다. 다만 동사를 많이 사용합니다. 왜냐하면 변수를 보통 명사로 사용하기 때문에 메소드는 변수를가지고 만드는 어떤 장치의 개념이라 생각하시면 됩니다. 매개변수는 외부에서 전달받을 값의 타입을 맞추어 선언합니다.

**메소드 주의사항**

메소드 선언은 반드시 메소드 밖에서 해야 하며,

메소드 사용은 반드시 메소드 안에서 해야 한다.

중괄호가 열려 있다면, 메소드 선언!

중괄호가 없다면 메소드 사용!

이것만 알고 있어도 앞으로 이 메소드가 선언인지 다른 메소드 안에서 호출이 된건지 알 수 있습니다.

이제 한번 만들어 보겠습니다.

```
public class MethodTest {

	
	int f(int x){
		int result = 2*x+1;
		return result;
	}
	
	
	public static void main(String[] args) {
		MethodTest m = new MethodTest();
	
		
		System.out.println((double)m.f(3));
		System.out.println((char)(m.f(2)+ 'A'));
	}

}
```

먼저 main메소드 밖에서 f라는 메소드를 선언합니다. result라는 정수타입의 변수를 만들고 리턴값을 그 result값으로 주었습니다. 이거를 메인 메소드에서 사용을 해야하는데요. C언어에서는 바로 사용을 할 수 있었지만 JAVA에서는 MethodTest m = new MethodTest(); 라는 문장을 쓰고 사용한다고 합니다. 정확한 이유는 뒤에 배우면 다시 말씀드리겠습니다. 그리고 출력함수를 사용하여 입력함수 Scanner를 사용했을 때와 같이 우리가 만든 변수 m을 사용하여 m.f(값)을 이용하여 사용하면 됩니다. 한번 실행해 볼까요?

![Desktop View](/assets/img/Programming-Language/Java/Method/1.png)

f메소드는 정수타입이라 더블로 한번 강제형변환을 사용해준 모습입니다. 밑에는 'A'의 아스키 코드에 5를 더한 문자값이 출력됩니다. 따라서 5번 뒤의 알파벳인 F가 출력되는 모습! 재밌습니다 ㅎㅎ

이번시간에는 메소드에 대해서 살짝 알아봤습니다!